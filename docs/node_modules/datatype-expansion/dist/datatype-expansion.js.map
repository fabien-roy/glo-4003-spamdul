{"version":3,"file":"datatype-expansion.js","sources":["../src/expanded.js","../src/canonical.js","../src/index.js"],"sourcesContent":["'use strict'\n\nconst _ = require('lodash')\n\nconst isOpaqueType = require('./util').isOpaqueType\n\n/**\n * Accepts an in-memory JSON representation of the type, the types mapping\n * and a callback function. If the invocation succeeds, it will return the\n * expanded form as an argument to the provided callback function.\n *\n * @param type {(Object|String)} The form being expanded\n * @param types {object} An object with entries mapping from user\n *                   defined RAML type names to RAML type forms\n * @param cb {Function|object} Callback or options\n */\nmodule.exports.expandedForm = function expandedForm (type, types, cb) {\n  let options = {}\n  if (typeof cb === 'object') {\n    options = cb\n    cb = options.callback\n  }\n\n  const visited = {}\n  for (const key in types) {\n    if (types[key] === type) {\n      visited[key] = true\n      break\n    }\n  }\n\n  if (cb == null) {\n    return expandForm(type, types, visited, options)\n  }\n\n  setTimeout(() => {\n    let result\n    try {\n      result = expandForm(type, types, visited, options)\n    } catch (e) {\n      cb(e, null)\n      return\n    }\n    cb(null, result)\n  }, 0)\n}\n\n/**\n * @param form {*} The form being expanded\n * @param bindings {object} An object with entries mapping from user\n *                   defined RAML type names to RAML type forms\n * @param visited {object} An object with properties indicating already 'visited' type names\n * @param options {object} Expansion options\n * @returns {object} - expanded form\n */\nfunction expandForm (form, bindings, visited, options) {\n  // apparently they want this\n  if (typeof form === 'string') {\n    try {\n      JSON.parse(form)\n      form = {\n        type: 'json',\n        content: form\n      }\n    } catch (e) {}\n  }\n\n  // 1. if `form` is a `String\n  if (typeof form === 'string') {\n    // strip parentheses around entire form\n    if (/^\\(.+\\)$/.test(form)) {\n      form = form.match(/^\\((.+)\\)$/)[1]\n    }\n\n    // 1.1. if `form` is a RAML built-in data type, we return `(Record \"type\" form)`\n    if (isOpaqueType(form) || form === 'object' || form === 'array') {\n      return { type: form }\n    }\n\n    if (form.endsWith('?')) {\n      if (isOpaqueType(form.replace('?', ''))) {\n        return expandUnion({\n          type: 'union',\n          anyOf: [\n            { type: form.replace('?', '') },\n            { type: 'nil' }\n          ]\n        }, bindings, visited, options)\n      }\n    }\n\n    if (form.endsWith('[]')) { // Array\n      const match = form.match(/^(.+)\\[]$/)[1]\n      return {\n        type: 'array',\n        items: expandForm(match, bindings, visited, options)\n      }\n    }\n\n    // 1.2. if `form` is a Type Expression, we return the output of calling the algorithm\n    // recursively with the parsed type expression and the provided `bindings`\n    if (/^[^|\\s]+(?:\\|[^|\\s]+)+$/.test(form.replace(/\\s+/g, ''))) { // union\n      const alternatives = form.split('|').map(s => s.trim())\n      return expandUnion({ anyOf: alternatives, type: 'union' }, bindings, visited, options)\n    }\n\n    // 1.3. if `form` is a key in `bindings`\n    if (form in bindings) {\n      // 1.3.2. If the type has been traversed\n      if (form in visited) {\n        // 1.3.2.1. We mark the value for the current form as a fixpoint recursion: `$recur`\n        // 1.3.2.2. We find the container form matching the recursion type and we wrap it into a `(fixpoint RAMLForm)` form.\n        // not sure what that means\n        return { type: '$recur' }\n      } else {\n        // 1.3.1. If the type hasn't been traversed yet, we return the output of invoking\n        // the algorithm recursively with the value for `form` found in `bindings` and the\n        // `bindings` mapping and we add the type to the current traverse path\n        visited = Object.assign({ [form]: true }, visited)\n        let type = bindings[form]\n        if (options.trackOriginalType && !(typeof type === 'object')) {\n          type = { type } // ensure type is in object form\n        }\n        type = expandForm(type, bindings, visited, options)\n        // set originalType after recursive expansion to retain first type expanded\n        if (options.trackOriginalType) {\n          type.originalType = form\n        }\n        return type\n      }\n    }\n\n    // 1.4. else we return an error\n    throw new Error('could not resolve: ' + form)\n  } else if (typeof form === 'object') {\n    form = _.cloneDeep(form)\n    if (Array.isArray(form)) {\n      form = {\n        type: form\n      }\n    }\n    // 2. if `form` is a `Record`\n    // 2.1. we initialize a variable `type`\n    // 2.1.1. if `type` has a defined value in `form` we initialize `type` with that value\n    // 2.1.2. if `form` has a `properties` key defined, we initialize `type` with the value `object`\n    // 2.1.3. if `form` has a `items` key defined, we initialize `type` with the value `object`\n    // 2.1.4. otherwise we initialise `type` with the value passed in `top-level-type`\n    form.type = form.type || (form.properties && 'object') || (form.items && 'array') || options.topLevel || 'any'\n\n    if (typeof form.type === 'string') {\n      if (form.type === 'array') {\n        // 2.2. if `type` is a `String` with  value `array`\n        return expandArray(form, bindings, visited, options)\n      } else if (form.type === 'object') {\n        // 2.3 if `type` is a `String` with value `object`\n        return expandObject(form, bindings, visited, options)\n      } else if (form.type === 'union') {\n        // 2.4. if `type` is a `String` with value `union`\n        return expandUnion(form, bindings, visited, options)\n      } else if (form.type in bindings) {\n        // 2.5. if `type` is a `String` with value in `bindings`\n        form = expandNested(form, bindings, visited, options)\n        form.type = expandForm(form.type, bindings, visited, options)\n      } else {\n        form = Object.assign(form, expandForm(form.type, bindings, visited, options))\n      }\n    } else if (Array.isArray(form.type)) {\n      // 2.7. if `type` is a `Seq[RAMLForm]`\n      form = expandNested(form, bindings, visited, options)\n      form.type = form.type.map(t => expandForm(t, bindings, visited, options))\n    } else if (typeof form.type === 'object') {\n      // 2.6. if `type` is a `Record`\n      form = expandNested(form, bindings, visited, options)\n      form.type = expandForm(form.type, bindings, visited, options)\n    } else {\n      form = Object.assign(form, expandForm(form.type, bindings, visited, options))\n    }\n\n    if (form.facets != null) {\n      _.each(form.facets, (propValue, propName) => {\n        form.facets[propName] = expandForm(propValue, bindings, visited, options)\n      })\n    }\n\n    return form\n  }\n\n  throw new Error('form can only be a string or an object')\n}\n\nfunction expandNested (form, bindings, visited, options) {\n  if (form.properties !== undefined) form = expandObject(form, bindings, visited, options)\n  if (form.anyOf !== undefined) form = expandUnion(form, bindings, visited, options)\n  if (form.items !== undefined) form = expandArray(form, bindings, visited, options)\n  return form\n}\n\nfunction expandArray (form, bindings, visited, options) {\n  form.items = expandForm(form.items || 'any', bindings, visited, options)\n  return form\n}\n\nfunction expandObject (form, bindings, visited, options) {\n  const props = form.properties\n  for (let propName in props) {\n    if (!Object.prototype.hasOwnProperty.call(props, propName)) continue\n\n    const expandedPropVal = expandForm(props[propName] || 'any', bindings, visited, options)\n    if (propName.endsWith('?')) {\n      delete props[propName]\n      propName = propName.slice(0, -1)\n      expandedPropVal.required = false\n    }\n    if (expandedPropVal.required === undefined) {\n      expandedPropVal.required = true\n    }\n    props[propName] = expandedPropVal\n  }\n  if (form.additionalProperties === undefined) {\n    form.additionalProperties = true\n  }\n  return form\n}\n\nfunction expandUnion (form, bindings, visited, options) {\n  form.anyOf = form.anyOf.map(elem => expandForm(elem, bindings, visited, options))\n  return form\n}\n","'use strict'\n\nconst _ = require('lodash')\n\nconst minType = require('./minType')\nconst consistencyCheck = require('./util').consistencyCheck\nconst isOpaqueType = require('./util').isOpaqueType\n\n/**\n * Accepts a JSON in-memory representation of an expanded RAML type and a\n * callback function. Callback function should accept two arguments: error\n * and canonical form object.\n *\n * @param expForm {object} the (previously) expanded form\n * @param cb {Function|object} callback or options\n */\nmodule.exports.canonicalForm = function canonicalForm (expForm, cb) {\n  let options = {}\n  if (typeof cb === 'object') {\n    options = cb\n    cb = options.callback\n  }\n  if (cb == null) {\n    return toCanonical(expForm, options)\n  }\n\n  setTimeout(() => {\n    let result\n    try {\n      result = toCanonical(expForm, options)\n    } catch (e) {\n      cb(e, null)\n      return\n    }\n    cb(null, result)\n  }, 0)\n}\n\nfunction toCanonical (form, options) {\n  form = _.cloneDeep(form) // just to be on the safe side\n\n  // 1. we initialize the variable type with the value of the property `type` of `expanded-form`\n  const type = form.type\n\n  if (isOpaqueType(type)) {\n    // 2. if `type` is in the set `any boolean datetime datetime-only number integer string null file xml json`\n    // 2.1. we return the output of applying the `consistency-check` to the `form`\n    return consistencyCheck(form)\n  } else if (type === 'array') {\n    // 3. if `type` is the string `array`\n    // 3.1. we replace the property `items` in `form` with the output of applying the algorithm to\n    // the value of the key `items` of the input `form` (or `any` if the key `items` is not defined)\n    form.items = toCanonical(form.items || { type: 'any' }, options)\n    // 3.2. we return the output of applying the `consistency-check` algorithm to the new value of `form`\n    return consistencyCheck(form)\n  } else if (type === 'object') {\n    // 4. if `type` is the string `object`\n    // 4.1. we initialize the variable properties with the value of the `properties` key in `form`\n    const properties = form.properties\n    // 4.2. we initialize the variable `accum` with the cloned value of `form`\n    let accum = [_.cloneDeep(form)]\n    // 4.3. we reset the key `properties` in `accum` to an empty record\n    accum[0].properties = {}\n    // 4.4. for each pair `property-name` and `property-value` in the variable `properties`\n    _.each(properties, (propValue, propName) => {\n      // 4.4.1. we initialize the variable `tmp` with the output of invoking the algorithm over the value in `property-value`\n      const tmp = toCanonical(propValue, options)\n      if (tmp.type === 'union' && options.hoistUnions !== false) {\n        // 4.4.3. if the property `type` of `tmp` has the value `union` and union hoisting is not disabled\n        // 4.4.3.1. we initialize the variable `new-accum` to the empty sequence\n        const newAccum = []\n        // 4.4.3.2. for each value `elem-of` in the property `of` of `tmp`\n        tmp.anyOf.forEach((elemOf) => {\n          // 4.4.3.2.1. for each value `elem` in `accum`\n          if (typeof form.required === 'boolean') {\n            elemOf.required = tmp.required\n          }\n          for (let elem of accum) {\n            // 4.4.3.2.1.1. we clone `elem`\n            elem = _.cloneDeep(elem)\n            // 4.4.3.2.1.2. we clone `tmp` as `new-value`, except for `of`, and assign the properties of `elem-of` to it\n            const newValue = Object.assign({}, tmp, elemOf)\n            delete newValue.anyOf\n            // 4.4.3.2.1.3. we add the pair `property-name` `new-value` to the key `properties` of the cloned `elem`\n            elem.properties[propName] = newValue\n            // 4.4.3.2.1.4. we add the cloned  `elem` to the sequence `new-accum`\n            newAccum.push(elem)\n          }\n        })\n        // 4.4.3.3. we replace `accum` with `new-accum`\n        accum = newAccum\n      } else {\n        // 4.4.2. if the property `type` of `tmp` has the value `object`\n        // 4.4.2.1. we add the pair `property-name` `tmp` to the `properties` keys in each record in `accum`\n        accum = accum.map((elem) => {\n          elem.properties[propName] = tmp\n          return elem\n        })\n      }\n    })\n    if (accum.length === 1) {\n      // 4.4.4. if `accum` contains a single element\n      // 4.4.4.1. we return  the output of applying the `consistency-check` algorithm to the only element in `accum`\n      return consistencyCheck(accum[0])\n    } else if (accum.length > 1) {\n      // 4.4.5. if `accum` contains more than one element\n      // 4.4.5.1. we replace the `type` of `form` with `union`\n      form.type = 'union'\n      // 4.4.5.2. we remove the keys `properties` and `additionalProperties`\n      delete form.properties\n      delete form.additionalProperties\n      // 4.4.5.3. we add the key `of` with the value of `accum`\n      form.anyOf = accum\n      // 4.4.5.4. we return  the output of applying the `consistency-check` algorithm to the modified value of `form`\n      return consistencyCheck(form)\n    }\n  } else if (type === 'union') {\n    // 5. if `type` is the string `union`\n    // 1. we recursively canonicalize forms nested within `of` in `form`\n    form.anyOf = form.anyOf.map(alt => toCanonical('type' in alt ? alt : { type: alt }, options))\n    // 2. we return the output of applying the `consistency-check` algorithm to the modified value of `form`\n    return consistencyCheck(form)\n  } else if (typeof type === 'object') {\n    // 6. & 7.\n    // 1. we initialize the variable `super-type-name` to the first value of type string in the chain of nested records for the value `type` starting with the one assigned to `type` in `form`\n    const superTypeName = findClass(form)\n    let subType = _.cloneDeep(form)\n    subType.type = superTypeName\n\n    switch (superTypeName) {\n      case 'object':\n        // 1.2. if `super-type-name` has a value `object` we transform `form` adding the property `properties` with the empty record `(Record)`\n        subType.properties = subType.properties || {}\n        break\n      case 'array':\n        // 1.1. if `super-type-name` has a value `array` we transform `form` adding the property `items` pointing a record `(Record \"type\" \"any\")`\n        subType.items = subType.items || { type: 'any' }\n        break\n      case 'union':\n        // 1.3. if `super-type-name` has a value `union` we transform `form` adding the property `of` with the empty sequence `(Seq)`\n        subType.anyOf = subType.anyOf || []\n        break\n    }\n\n    if (Array.isArray(type)) {\n      const superTypes = _.cloneDeep(type).map(t => toCanonical(t, options))\n      subType = superTypes.reduce((acc, val) => minType(val, acc), toCanonical(subType, options))\n      return subType\n    } else {\n      const superType = toCanonical(type, options)\n      const res = minType(superType, toCanonical(subType, options))\n      return res\n    }\n  }\n\n  return form\n}\n\nfunction findClass (form) {\n  if (form.properties !== undefined) return 'object'\n  if (form.items !== undefined) return 'array'\n  if (typeof form.type === 'string') return form.type\n  if (typeof form.type === 'object') {\n    if (Array.isArray(form.type)) {\n      const type = form.type.map((node) => {\n        try {\n          return findClass(node)\n        } catch (e) {\n          return null\n        }\n      }).filter(type => type !== null)[0]\n      if (type !== undefined) {\n        return type\n      }\n    } else {\n      return findClass(form.type)\n    }\n  }\n  throw new Error('Cannot find top level class for node, not in expanded form')\n}\n","'use strict'\n\nconst expanded = require('./expanded')\nconst canonical = require('./canonical')\n\nmodule.exports = {\n  expandedForm: expanded.expandedForm,\n  canonicalForm: canonical.canonicalForm\n}\n"],"names":["_","require","isOpaqueType","expandForm","form","bindings","visited","options","JSON","parse","type","content","e","test","match","endsWith","replace","expandUnion","anyOf","items","split","map","s","trim","Object","assign","trackOriginalType","_typeof","originalType","Error","cloneDeep","Array","isArray","properties","topLevel","expandArray","expandObject","expandNested","t","facets","each","propValue","propName","undefined","props","prototype","hasOwnProperty","call","expandedPropVal","slice","required","additionalProperties","elem","module","exports","expandedForm","types","cb","callback","key","setTimeout","result","minType","consistencyCheck","toCanonical","accum","tmp","hoistUnions","newAccum","forEach","elemOf","newValue","push","length","alt","superTypeName","findClass","node","filter","subType","reduce","acc","val","superType","canonicalForm","expForm","expanded","canonical"],"mappings":"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"}